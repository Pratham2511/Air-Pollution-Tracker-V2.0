-- Phase 2 Authentication Schema
-- Generated at 2025-10-10

create extension if not exists "uuid-ossp";

create table if not exists public.profiles (
  id uuid primary key references auth.users on delete cascade,
  full_name text not null,
  department text,
  jurisdiction text,
  role text not null check (role in ('citizen','government','admin')),
  government_role text,
  government_verified boolean default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger update_profiles_updated_at
  before update on public.profiles
  for each row
  execute procedure public.set_updated_at();

create table if not exists public.otp_requests (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid references auth.users on delete cascade,
  email text not null,
  channel text not null,
  status text not null default 'pending',
  expires_at timestamptz not null,
  metadata jsonb default '{}'::jsonb,
  requested_at timestamptz not null default now()
);

create index if not exists otp_requests_email_idx on public.otp_requests (email);
create index if not exists otp_requests_status_idx on public.otp_requests (status);
create index if not exists otp_requests_expires_at_idx on public.otp_requests (expires_at);

create table if not exists public.audit_logs (
  id bigint generated by default as identity primary key,
  event_type text not null,
  route text,
  user_id uuid,
  role text,
  outcome text,
  metadata jsonb default '{}'::jsonb,
  recorded_at timestamptz not null default now()
);

comment on table public.profiles is 'User profile records with role-based metadata.';
comment on table public.otp_requests is 'Email OTP verification requests for citizen and government flows.';
comment on table public.audit_logs is 'Security and access audit trail.';

-- Row Level Security & Policies
alter table public.profiles enable row level security;
alter table public.otp_requests enable row level security;
alter table public.audit_logs enable row level security;

drop policy if exists profiles_owner_select on public.profiles;
create policy "profiles_owner_select"
  on public.profiles for select
  using (auth.uid() = id or auth.jwt()->>'role' = 'admin');

drop policy if exists profiles_owner_upsert on public.profiles;
create policy "profiles_owner_upsert"
  on public.profiles for insert
  with check (auth.uid() = id or auth.role() = 'anon');

drop policy if exists profiles_owner_update on public.profiles;
create policy "profiles_owner_update"
  on public.profiles for update
  using (auth.uid() = id or auth.jwt()->>'role' = 'admin')
  with check (auth.uid() = id or auth.jwt()->>'role' = 'admin');

drop policy if exists otp_requests_self_access on public.otp_requests;
create policy "otp_requests_self_access"
  on public.otp_requests for select
  using (auth.uid() = user_id or auth.jwt()->>'role' = 'admin');

drop policy if exists otp_requests_insert_pending on public.otp_requests;
create policy "otp_requests_insert_pending"
  on public.otp_requests for insert
  with check (user_id is null or auth.uid() = user_id or auth.jwt()->>'role' = 'admin');

drop policy if exists audit_logs_insert_scoped on public.audit_logs;
create policy "audit_logs_insert_scoped"
  on public.audit_logs for insert
  with check (user_id is null or auth.uid() = user_id or auth.jwt()->>'role' = 'admin');

drop policy if exists audit_logs_select_admin on public.audit_logs;
create policy "audit_logs_select_admin"
  on public.audit_logs for select
  using (auth.jwt()->>'role' = 'admin');
